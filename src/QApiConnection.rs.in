extern crate bytes;
extern crate mio;
extern crate serde_json;

use std::collections::HashMap;

use bytes::{Buf, ByteBuf, MutByteBuf, SliceBuf};
use mio::*;
use mio::tcp::{TcpStream};

use std::io;

enum ClientState{
    ReadyForGreeting,
    ReadyForCapabilities,
    ReadyForCommands,
    Ready,
}

//QEMU Greeting
#[derive(Debug,Deserialize)]
struct RustVersion{
    major: u32,
    micro: u32,
    minor: u32,
}
#[derive(Debug,Deserialize)]
struct Version{
    package: String,
    qemu: RustVersion,
}

#[derive(Debug,Deserialize)]
struct QemuGreeting{
    #[serde(rename="QMP")]
    qmp: QMP,
}

#[derive(Debug,Deserialize)]
struct QMP{
    capabilities: Vec<String>,
    version: Version,
}

#[derive(Debug,Deserialize)]
struct Command{
    name: String,
}

#[derive(Debug,Deserialize)]
struct QemuCommands{
    #[serde(rename="return")]
    commands: Vec<Command>,
}

pub struct QApiConnection{
    sock: TcpStream,
    buf: Option<ByteBuf>,
    mut_buf: Option<MutByteBuf>,
    token: Token,
    interest: EventSet,
    state: ClientState,
}

struct QemuEventHandler{
    /// Takes a String Event name and matches it up with a Function to process the event
    handlers: HashMap<String,Box<(Fn(String))>>
}


impl QApiConnection{
    pub fn new(sock: TcpStream) -> QApiConnection {
        QApiConnection {
            buf: None,
            sock: sock,
            mut_buf: Some(ByteBuf::mut_with_capacity(4096)),
            token: Token(1),
            interest: EventSet::none(),
            state: ClientState::ReadyForGreeting,
        }
    }

    fn parse_greeting<'a>(&self, bytes: &'a [u8]){
        let result: QemuGreeting = serde_json::from_slice(bytes).unwrap();
        println!("Serde result: {:?}", result);
    }

    fn parse_capabilities<'a>(&self, bytes: &'a [u8]){
        let result: serde_json::Value = serde_json::from_slice(bytes).unwrap();
        println!("Serde capabilities result: {:?}", result);
    }

    fn parse_commands<'a>(&self, bytes: &'a [u8]){
        let result: QemuCommands = serde_json::from_slice(bytes).unwrap();
        println!("Serde commands result: {:?}", result);
    }

    ///There's an initial ping/pong type communication going on between the client and the
    ///qemu server to figure out what version we're talking and what the server is capable of.
    ///Once the ClientState settles into ClientState::Ready then we're ready to take
    ///user commands.
    fn read_event(&mut self, event_loop: &mut EventLoop<QApiConnection>) -> io::Result<()> {
        println!("Socket readable");

        //TODO: This returns None sometimes?  Why
        //let mut buf = self.mut_buf.take().unwrap();
        let mut buf = ByteBuf::mut_with_capacity(4096);

        match self.sock.try_read_buf(&mut buf) {
            Ok(None) => {
                println!("CONN : spurious read wakeup");
                self.mut_buf = Some(buf);
            }
            Ok(Some(r)) => {
                println!("CONN : we read {} bytes!", r);

                match self.state{
                    ClientState::ReadyForGreeting => {
                        self.parse_greeting(buf.bytes());

                        self.interest.remove(EventSet::readable());
                        self.interest.insert(EventSet::writable());

                        let reply = ByteBuf::from_slice("{ \"execute\": \"qmp_capabilities\" }".as_bytes());
                        self.buf = Some(reply);
                        //Update our state
                        //Lets ask for the capabilities set
                        self.state = ClientState::ReadyForCapabilities;
                    },
                    ClientState::ReadyForCapabilities => {
                        self.parse_capabilities(buf.bytes());

                        let reply = ByteBuf::from_slice("{ \"execute\": \"query-commands\" }".as_bytes());
                        self.buf = Some(reply);
                        //Update our state
                        //Lets ask for the capabilities set
                        self.state = ClientState::ReadyForCommands;
                        self.interest.remove(EventSet::readable());
                        self.interest.insert(EventSet::writable());
                    },
                    ClientState::ReadyForCommands => {
                        self.parse_commands(buf.bytes());

                        //Update our state
                        //Lets ask for the capabilities set
                        self.state = ClientState::Ready;

                        //TODO: Ok how do we wait for user input now?
                        self.interest.remove(EventSet::readable());
                        self.interest.insert(EventSet::writable());
                    },
                    ClientState::Ready => {
                        //Ready to receive events and user input
                        self.interest.remove(EventSet::readable());
                        self.interest.insert(EventSet::writable());
                    },
                }
            }
            Err(e) => {
                println!("not implemented; client err={:?}", e);
                self.interest.remove(EventSet::readable());
            }
        };

        event_loop.reregister(&self.sock, self.token, self.interest,
                              PollOpt::edge())
    }

    fn write_event(&mut self, event_loop: &mut EventLoop<QApiConnection>) -> io::Result<()> {
        println!("client socket writable");
        let mut buf = self.buf.take().unwrap();

        match self.state{
            ClientState::ReadyForGreeting => {
                //Nothing to do here
            },
            ClientState::ReadyForCapabilities => {
                //Lets ask for the capabilities set
                match self.sock.try_write_buf(&mut buf) {
                    Ok(None) => {
                        println!("client flushing buf; WOULDBLOCK");
                        self.interest.insert(EventSet::writable());
                    }
                    Ok(Some(r)) => {
                        println!("CLIENT : we wrote {} bytes!", r);

                        self.interest.insert(EventSet::readable());
                        self.interest.remove(EventSet::writable());
                    }
                    Err(e) => println!("not implemented; client err={:?}", e)
                }

                self.interest.insert(EventSet::readable());
                self.interest.remove(EventSet::writable());
            },
            ClientState::ReadyForCommands => {
                //Lets ask for the capabilities set
                match self.sock.try_write_buf(&mut buf) {
                    Ok(None) => {
                        println!("client flushing buf; WOULDBLOCK");
                        self.interest.insert(EventSet::writable());
                    }
                    Ok(Some(r)) => {
                        println!("CLIENT : we wrote {} bytes!", r);

                        self.interest.insert(EventSet::readable());
                        self.interest.remove(EventSet::writable());
                    }
                    Err(e) => println!("not implemented; client err={:?}", e)
                }

                self.interest.insert(EventSet::readable());
                self.interest.remove(EventSet::writable());
            },
            ClientState::Ready => {
                //Ready to receive events and user input
                self.interest.insert(EventSet::readable());
                self.interest.remove(EventSet::writable());
            },
        }

        event_loop.reregister(&self.sock, self.token, self.interest,
                              PollOpt::edge() | PollOpt::oneshot())
    }
}

impl Handler for QApiConnection {
    type Timeout = ();
    type Message = ();

    fn ready(&mut self, event_loop: &mut EventLoop<QApiConnection>, token: Token, events: EventSet) {
        println!("ready {:?} {:?}", token, events);
        if events.is_readable(){
            match token {
                CLIENT => self.read_event(event_loop).unwrap(),
            }
        }
        if events.is_writable(){
            match token {
                CLIENT => {
                    //let mut reply = ByteBuf::from_slice("".as_bytes());
                    //TODO: Set or allow setting of buf to write back a reply
                    self.write_event(event_loop).unwrap()
                },
            }
        }
    }

}
